\chapter{MULgraph geometry files}
\label{mulgrids}

\section{Introduction}
The \texttt{mulgrids} library in PyTOUGH contains classes and routines for creating, editing and saving MULgraph geometry files.  It can be imported using the command:

 \texttt{\\
   from mulgrids import *}

\section{\texttt{mulgrid} objects}

The \texttt{mulgrids} library defines a \texttt{mulgrid} class, used for representing MULgraph geometry files.

\textbf{Example:}

\begin{verbatim}
geo=mulgrid()
\end{verbatim}

creates an empty \texttt{mulgrid} object called \texttt{geo}.

\begin{verbatim}
geo=mulgrid(`geom.dat')
\end{verbatim}

creates a \texttt{mulgrid} object called \texttt{geo} and reads its contents from a file named \texttt{`geom.dat'}.

Printing a \texttt{mulgrid} object (e.g. \texttt{print geo}) displays a summary of information about the grid: how many nodes, columns, layers, blocks and wells it contains, as well as its naming convention and atmosphere type.

\subsection{Properties}

The main properties of a \texttt{mulgrid} object are listed in Table \ref{tb:mulgrid_properties}.  Some of these properties are `header' information, corresponding to the data at the start of a MULgraph geometry file (\texttt{type}, \texttt{convention}, \texttt{atmosphere\_type}, \texttt{atmosphere\_volume}, \texttt{atmosphere\_connection} and \texttt{unit\_type}).

The most important properties of a \texttt{mulgrid} object are \texttt{node}, \texttt{column}, \texttt{connection}, \texttt{layer} and \texttt{well}, which are dictionaries of the grid nodes, columns, connections, layers and wells, accessed by name.  For example, grid layer `AA' of a \texttt{mulgrid} object \texttt{geo} can be accessed by \texttt{geo.layer[`AA']}.  (The \texttt{nodelist}, \texttt{columnlist}, \texttt{connectionlist}, \texttt{layerlist} and \texttt{welllist} properties offer access to the nodes, columns, connections, layers and wells by index, which is sometimes useful e.g. for looping over all columns in the grid.)

Connections are slightly different from nodes, columns etc. in that they are not named individually.  However, they can be accessed by the names of the columns connected by the connection.  For example, the connection between columns ` 10' and ` 11' in a \texttt{mulgrid} called \texttt{geo} is given by \texttt{geo.connection[` 10',` 11']}.

The elements of these lists and dictionaries are of type \texttt{node}, \texttt{column}, \texttt{connection}, \texttt{layer} and \texttt{well} respectively.  These are additional object classes to represent nodes, columns, connections, layers and wells, defined in the \texttt{mulgrids} library (see section \ref{other_mulgrid_objects}).

\subsection{Naming conventions and atmosphere types}

The grid block naming convention and atmosphere type used in the \texttt{mulgrid} object, specified by the \texttt{convention} and \texttt{atmosphere\_type} parameters, are both integers which can be given the value 0, 1 or 2.  The meanings of these values are shown in Table \ref{tb:mulgrid_conventions} and \ref{tb:mulgrid_atmosphere_types}.

\begin{table}
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      0 & 3 characters for column followed by 2 digits for layer \\
      1 & 3 characters for layer followed by 2 digits for column \\
      2 & 2 characters for layer followed by 3 digits for column \\
      \hline
    \end{tabular}
    \caption{Naming conventions of a \texttt{mulgrid} object}
    \label{tb:mulgrid_conventions}
  \end{center}
\end{table}

\begin{table}
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      0 & A single atmosphere block \\
      1 & One atmosphere block over each column \\
      2 & No atmosphere blocks \\
      \hline
    \end{tabular}
    \caption{Atmosphere types of a \texttt{mulgrid} object}
    \label{tb:mulgrid_atmosphere_types}
  \end{center}
\end{table}

\subsubsection{Grid diagnostics}

A \texttt{mulgrid} object has some properties (and methods) for evaluating its integrity.  The property \texttt{column\_angle\_ratio} returns an \texttt{np.array} of the `angle ratio' for each column (the ratio of largest to smallest interior angles -- see section \ref{columnobjects}), a measure of skewness.  The \texttt{column\_side\_ratio} returns an \texttt{np.array} of the `side ratio' for each column (the ratio of largest to smallest side length), a measure of elongation.  These array properties can be plotted using the \texttt{layer\_plot} method (see section \ref{mulgridmethods}) for a graphical overview of grid quality.

There is also a \texttt{connection\_angle\_cosine} property, which returns an \texttt{np.array} of the angle cosine for each connection (the cosine of the angle between a line joining the nodes in the connection and a line joining the centres of the blocks in the connection).  In general it is desirable for these lines to be as close to perpendicular as possible, making the cosines close to zero.

The \texttt{bad\_columns}, \texttt{bad\_layers}, \texttt{missing\_connections}, \texttt{extra\_connections} and \texttt{orphans} properties return actual problems with the grid which should be fixed.  A summary of all these problems is given by the \texttt{check} method (see section \ref{mulgridmethods}).

Blocks at the ground surface that have very small vertical thickness can sometimes cause problems.  The \texttt{min\_surface\_block\_thickness} property gives a tuple containing the minimum surface block thickness and the name of the column in which it occurs.  Thin surface blocks of this type can be eliminated using the \texttt{snap\_columns\_to\_layers()} method.

\begin{center}
  \begin{longtable}{|l|l|p{75mm}|}
    \hline
    \textbf{Property} & \textbf{Type} & \textbf{Description}\\
    \hline
    \texttt{area} & float & total horizontal area covered by the grid \\
    \texttt{atmosphere\_connection} & float & connection distance to atmosphere blocks\\
    \texttt{atmosphere\_type} & integer & type of atmosphere\\
    \texttt{atmosphere\_volume} & float & volume of atmosphere blocks\\
    \texttt{bad\_columns} & set & columns that do not contain their own centres\\
    \texttt{bad\_layers} & set & layers that do not contain their own centres\\
    \texttt{block\_name\_index} & dictionary & indices of blocks (by name)\\
    \texttt{block\_name\_list} & list & names of blocks (by index)\\
    \texttt{boundary\_columns} & set & set of columns on the outer boundary of the grid \\
    \texttt{boundary\_nodes} & list & ordered list of nodes on the outer boundary of the grid \\
    \texttt{boundary\_polygon} & list & list of points representing grid boundary (extra colinear points removed) \\
    \texttt{bounds} & list & [bottom left, top right] horizontal bounds of grid\\
    \texttt{centre} & \texttt{np.array} & position of horizontal centre of the grid \\
    \texttt{columnlist} & list & columns (by index, e.g. \texttt{columnlist[23]})\\
    \texttt{column\_angle\_ratio} & \texttt{np.array} & angle ratio for each column\\
    \texttt{column\_side\_ratio} & \texttt{np.array} & side ratio for each column\\
    \texttt{column} & dictionary & columns (by name, e.g. \texttt{column[`AA']})\\
    \texttt{connection\_list} & list & connections between columns (by index)\\
    \texttt{connection\_angle\_cosine} & \texttt{np.array} & angle cosines for all connections\\
    \texttt{convention} & integer & naming convention for columns and layers\\
    \texttt{default\_surface} & Boolean  & \texttt{True} if all columns have default surface elevation\\
    \texttt{extra\_connections} & set & connections defined between columns that are not against each other\\
    \texttt{filename} & string  & file name on disk\\
    \texttt{node\_kdtree} & \texttt{cKDTree} & tree structure for fast searching for nodes \\
    \texttt{layerlist} & list & layers (by index)\\
    \texttt{layer} & dictionary & layers (by name)\\
    \texttt{min\_surface\_block\_thickness} & (float, string) & thickness of thinnest surface block (and associated column name)\\
    \texttt{missing\_connections} & set & missing connections between columns\\
    \texttt{nodelist} & list  & nodes (by index)\\
    \texttt{node} & dictionary  & nodes (by name)\\
    \texttt{num\_atmosphere\_blocks} & integer & number of atmosphere blocks\\
    \texttt{num\_blocks} & integer & total number of blocks in the grid\\
    \texttt{num\_columns} & integer & number of columns\\
    \texttt{num\_connections} & integer & number of connections between columns\\
    \texttt{num\_layers} & integer & number of layers\\
    \texttt{num\_nodes} & integer & number of nodes\\
    \texttt{num\_underground\_blocks} & integer & number of non-atmosphere blocks\\
    \texttt{num\_wells} & integer & number of wells\\
    \texttt{orphans} & set & orphaned nodes (nodes not belonging to any column)\\
    \texttt{permeability\_angle} & float & rotation angle (degrees anticlockwise) of first horizontal permeability direction \\
    \texttt{type} & string  & type of geometry (currently only `GENER' supported)\\
    \texttt{unit\_type} & string & distance unit (blank for metres, `FEET' for ft)\\
    \texttt{welllist} & list & wells (by index)\\
    \texttt{well} & dictionary & wells (by name)\\
    \hline
    \caption{Properties of a \texttt{mulgrid} object}
    \label{tb:mulgrid_properties}
  \end{longtable}
\end{center}

\subsection{Methods}
\label{mulgridmethods}

The main methods of a \texttt{mulgrid} object are listed in Table \ref{tb:mulgrid_methods}.  Details of these methods are given below.

\begin{center}
\begin{longtable}{|l|l|p{70mm}|}
  \hline
  \textbf{Method} & \textbf{Type} & \textbf{Description}\\
  \hline
  \texttt{add\_column} & -- & adds a column to the grid\\ 
  \texttt{add\_connection} & -- & adds a connection to the grid\\ 
  \texttt{add\_layer} & -- & adds a layer to the grid\\ 
  \texttt{add\_node} & -- & adds a node to the grid\\ 
  \texttt{add\_well} & -- & adds a well to the grid\\ 
  \texttt{block\_contains\_point} & Boolean & whether a block contains a 3D point\\
  \texttt{block\_mapping} & dictionary & mapping from the blocks of another \texttt{mulgrid} object\\
  \texttt{block\_name} & string & name of block at given layer and column\\
  \texttt{block\_name\_containing\_point} & string & name of block containing specified point\\
  \texttt{check} & Boolean & checks grid for errors (and optionally fixes them)\\ 
  \texttt{column\_boundary\_nodes} & list & nodes around the outer boundary of a group of columns\\ 
  \texttt{column\_bounds} & list & bounding rectangle around a list of columns\\ 
  \texttt{column\_containing\_point} & column & column containing specified horizontal point\\ 
  \texttt{column\_mapping} & dictionary & mapping from the columns of another \texttt{mulgrid} object\\
  \texttt{column\_name} & string & column name of a block name\\ 
  \texttt{column\_neighbour\_groups} & list & groups connected columns\\ 
  \texttt{column\_quadtree} & quadtree & quadtree structure for searching columns\\ 
  \texttt{column\_surface\_layer} & \texttt{column} & surface layer for a specified column\\
  \texttt{column\_values} & tuple & values of a variable down a column\\
  \texttt{columns\_in\_polygon} & list & columns inside a specified polygon (or rectangle)\\ 
  \texttt{connects} & Boolean & whether the grid has a connection between two specified columns\\ 
  \texttt{copy\_layers\_from} & -- & copies layer structure from another geometry\\ 
  \texttt{copy\_wells\_from} & -- & copies wells from another geometry\\ 
  \texttt{delete\_column} & -- & deletes a column from the grid\\ 
  \texttt{delete\_connection} & -- & deletes a connection from the grid\\ 
  \texttt{delete\_layer} & -- & deletes a layer from the grid\\ 
  \texttt{delete\_node} & -- & deletes a node from the grid\\ 
  \texttt{delete\_orphans} & -- & deletes any orphaned nodes from the grid\\ 
  \texttt{delete\_orphan\_wells} & -- & deletes any orphaned wells from the grid\\ 
  \texttt{delete\_well} & -- & deletes a well from the grid\\ 
  \texttt{empty} & --  & empties contents of grid\\
  \texttt{export\_surfer} & -- & exports to various files on disk for visualization in Surfer\\ 
  \texttt{fit\_surface} & -- & fits column surface elevations from data\\ 
  \texttt{from\_gmsh} & \texttt{mulgrid} & imports a grid from a \texttt{gmsh} mesh\\ 
  \texttt{layer\_containing\_elevation} & layer & layer containing specified vertical elevation\\
  \texttt{layer\_mapping} & dictionary & mapping from the layers of another \texttt{mulgrid} object\\
  \texttt{layer\_name} & string & layer name of a block name\\ 
  \texttt{layer\_plot} & -- & plots a variable over a layer of the grid\\
  \texttt{line\_values} & tuple & values of a variable along an arbitrary line through the grid\\
  \texttt{line\_plot} & -- & plots a variable along an arbitrary line through the grid\\
  \texttt{nodes\_in\_columns} & list & nodes in a specified list of columns\\ 
  \texttt{nodes\_in\_polygon} & list & nodes inside a specified polygon (or rectangle)\\ 
  \texttt{node\_nearest\_to} & \texttt{node} & node nearest to a specified point\\ 
  \texttt{optimize} & -- & adjusts node positions to optimize grid quality\\
  \texttt{polyline\_values} & tuple & values of a variable along an arbitrary polyline through the grid\\
  \texttt{read} & \texttt{mulgrid} & reads geometry file from disk\\
  \texttt{rectangular} & \texttt{mulgrid} & creates rectangular grid\\
  \texttt{reduce} & -- & reduces a grid to contain only specified columns\\
  \texttt{refine} & -- & refines specified columns in the grid\\
  \texttt{refine\_layers} & -- & refines specified layers in the grid\\
  \texttt{rename\_column} & Boolean & renames a column\\
  \texttt{rename\_layer} & Boolean & renames a layer\\
  \texttt{rotate} & -- & rotates a grid in the horizontal plane\\
  \texttt{rotate} & -- & rotates a grid in the horizontal plane\\
  \texttt{slice\_plot} & -- & plots a variable over a vertical slice through the grid\\
  \texttt{snap\_columns\_to\_layers} & -- & snaps column surfaces to layer bottoms\\
  \texttt{split\_column} & Boolean & splits a quadrilateral column into two triangles\\ 
  \texttt{translate} & -- & moves a grid by simple translation in 3D\\
  \texttt{well\_values} & tuple & values of a variable down a well\\
  \texttt{write} & -- & writes to geometry file on disk\\
  \texttt{write\_bna} & -- & writes to Atlas BNA file on disk\\ 
  \texttt{write\_vtk} &  -- & writes to VTK file on disk\\
  \hline
  \caption{Methods of a \texttt{mulgrid} object}
  \label{tb:mulgrid_methods}
\end{longtable}
\end{center}

\subsubsection{\texttt{add\_column(\emph{col})}}

Adds a \texttt{column} object \texttt{col} to the grid.

\subsubsection{\texttt{add\_connection(\emph{con})}}

Adds a \texttt{connection} object \texttt{con} to the grid.

\subsubsection{\texttt{add\_layer(\emph{lay})}}

Adds a \texttt{layer} object \texttt{lay} to the grid.

\subsubsection{\texttt{add\_node(\emph{n})}}

Adds a \texttt{node} object \texttt{n} to the grid.

\subsubsection{\texttt{add\_well(\emph{w})}}

Adds a \texttt{well} object \texttt{w} to the grid.

\subsubsection{\texttt{block\_contains\_point(\emph{blockname}, \emph{pos})}}

Returns \texttt{True} if the grid block with the given name contains the 3D point \texttt{pos}.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{blockname}: string\\
  The name of the block.
\item \textbf{pos}: \texttt{np.array}\\
  3-element array representing the 3D point.
\end{itemize}

\subsubsection{\texttt{block\_mapping(\emph{geo}, \emph{column\_mapping}=\texttt{False})}}

Returns a dictionary mapping each block name in the \texttt{mulgrid} object \texttt{geo} to the name of the nearest block in the object's own geometry.  Can optionally also return the associated column mapping.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{geo}: \texttt{mulgrid}\\
  The \texttt{mulgrid} object to create a block mapping from.
\item \textbf{column\_mapping}: Boolean\\
  If \texttt{True}, the column mapping will also be returned (i.e. the function will return a tuple containing the block mapping and the column mapping).  Default value is \texttt{False}.
\end{itemize}

\subsubsection{\texttt{block\_name(\emph{layer\_name}, \emph{column\_name})}}

Gives the name of the block corresponding to the specified layer and column names, according to the naming convention of the grid.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{layer\_name}, \textbf{column\_name}: string\\
  Name of layer and column (the widths of these strings are determined by the grid's naming convention).
\end{itemize}

\subsubsection{\texttt{block\_name\_containing\_point(\emph{pos}, \emph{qtree}=None)}}

Gives the name of the block containing a specified 3-D position in the grid (returns \texttt{None} if the point lies outside the grid).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{pos}: \texttt{np.array}\\
  Position of point in 3-D
\item \textbf{qtree}: \texttt{quadtree}\\
  Quadtree object for fast searching of grid columns (can be constructed using the \texttt{column\_quadtree()} method).
\end{itemize}

\subsubsection{\texttt{check(\emph{fix}=False,\emph{silent}=False)}}

Checks a grid for errors and optionally fixes them.  Errors checked for are: missing connections, extra connections, orphaned nodes, and columns and layers that do not contain their own centres.  Returns \texttt{True} if no errors were found, and \texttt{False} otherwise.  If \texttt{fix} is \texttt{True}, any identified problems will be fixed.  If \texttt{silent} is \texttt{True}, there is no printout (only really useful if \texttt{fix} is \texttt{True}).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{fix}: Boolean\\
  Whether to fix any problems identified.
\item \textbf{silent}: Boolean\\
  Whether to print out feedback or not.
\end{itemize}

\subsubsection{\texttt{column\_boundary\_nodes(\emph{columns})}}

Returns the nodes around the outer boundary of a list of columns.  The list is ordered, in a counter-clockwise direction.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{columns}: list\\
  The list of columns for which the boundary is required.
\end{itemize}

\subsubsection{\texttt{column\_bounds(\emph{columns})}}

Returns a bounding rectangle around a list of columns.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{columns}: list\\
  The list of columns for which the bounds are required.
\end{itemize}

\subsubsection{\texttt{column\_containing\_point(\emph{pos}, \emph{columns}=None, \emph{guess}=None, \emph{bounds}=None,\\
\emph{qtree}=None)}}

Returns the grid column containing the specified horizontal point.  If \texttt{columns} is specified, only columns in the given list will be searched.  An initial \texttt{guess} column can optionally be specified.  If \texttt{bounds} is specified, points outside the given polygon will always return \texttt{None}.  A quadtree structure can also be specified to speed up searching.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{pos}: \texttt{np.array}\\
  Horizontal position (\emph{x}, \emph{y})
\item \textbf{columns}: list of \texttt{column} (or \texttt{None})\\
  List of columns to search.  If \texttt{None}, the entire grid will be searched.
\item \textbf{guess}: \texttt{column} (or \texttt{None})\\
  Guess of required column.  If specified, this column will be tested first, followed (if necessary) by its neighbours; only if none of these contain the point will the remaining columns be searched.  This can speed up the process if data follow a sequential pattern in space, e.g. a grid or lines.
 \item \textbf{bounds}: list of \texttt{np.array} (or \texttt{None})\\
  Polygon or rectangle representing e.g. the boundary of the grid: points outside this polygon will always return \texttt{None}.  If the polygon has only two points, it will be interpreted as a rectangle [bottom left, top right].
 \item \textbf{qtree}: \texttt{quadtree} \\
   A quadtree object for searching the columns of the grid.  If many points are to be located, this option can speed up the search.  The quadtree can be constructed before searching using e.g. \texttt{qtree = geo.column\_quadtree(columns)}, where \texttt{columns} is the list of \texttt{column} objects to be searched.
\end{itemize}

\subsubsection{\texttt{column\_mapping(\emph{geo})}}

Returns a dictionary mapping each column name in the \texttt{mulgrid} object \texttt{geo} to the name of the nearest column in the object's own geometry.  If the SciPy library is available, a KDTree structure is used to speed searching.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{geo}: \texttt{mulgrid}\\
  The \texttt{mulgrid} object to create a column mapping from.
\end{itemize}

\subsubsection{\texttt{column\_name(\emph{block\_name})}}

Gives the name of the column corresponding to the specified block name, according to the naming convention of the grid.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{block\_name}: string\\
  Block name.
\end{itemize}

\subsubsection{\texttt{column\_neighbour\_groups(\emph{columns})}}

From the given list or set of columns, finds sets of columns that are connected together, and returns a list of them.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{columns}: list or set\\
  List or set of columns to group.
\end{itemize}

\subsubsection{\texttt{column\_quadtree(\emph{columns}=None)}}

Returns a quadtree structure for fast searching of grid columns, to find which column a given point lies in.  This can then be passed into various other \texttt{mulgrid} methods that do such searching, e.g. \texttt{block\_name\_containing\_point()} or \texttt{well\_values}, to speed them up (useful for large grids).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{columns}: list (or \texttt{None})\\
  A list of columns in the grid, specifying the search area.  This parameter can be used to further speed searching if it is only necessary to search columns in a defined area.  If \texttt{None}, the search area is the whole grid (all columns).
\end{itemize}

\subsubsection{\texttt{column\_surface\_layer(\emph{col})}}

Returns the layer containing the surface elevation of a specified column.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{col}: \texttt{column}\\
  The column for which the surface layer is to be found.
\end{itemize}

\subsubsection{\texttt{column\_values(\emph{col}, \emph{variable}, \emph{depth} = False)}}

Returns values of a specified variable down a specified column.  The variable can be a list or \texttt{np.array} containing a value for every block in the grid.

The routine returns a tuple of two arrays (\texttt{d},\texttt{v}), the first (\texttt{d}) containing the elevation (or depth from surface if the \texttt{depth} parameter is set to \texttt{True}), and the second (\texttt{v}) containing the value of the variable at each block in the column.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{col}: \texttt{column} or string\\
  The column for which values are to be found.
\item \textbf{variable}: list (or \texttt{np.array})\\
  Values of variable, of length equal to the number of blocks in the grid.
\item \textbf{depth}: Boolean\\
  Set to \texttt{True} to give depths from surface, instead of elevations, as the first returned array.
\end{itemize}

\subsubsection{\texttt{columns\_in\_polygon(\emph{polygon})}}

Returns a list of all columns with centres inside the specified polygon or rectangle.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{polygon}: list (of \texttt{np.array})\\
  List of points defining the polygon (each point is a two-element \texttt{np.array}).  If the list has only two points, it will be interpreted as a rectangle [bottom left, top right].
\end{itemize}

\subsubsection{\texttt{connects(\emph{column1, column2})}}

Returns \texttt{True} if the geometry contains a connection connecting the two specified columns.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{column1, column2}: \texttt{column}\\
  Two columns in the geometry.
\end{itemize}

\subsubsection{\texttt{copy\_layers\_from(\emph{geo})}}

Copies the layer structure from the geometry \texttt{geo} (deleting any existing layers first).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{geo}: \texttt{mulgrid}\\
  The geometry to copy layers from.
\end{itemize}

\subsubsection{\texttt{copy\_wells\_from(\emph{geo})}}

Copies the wells from the geometry \texttt{geo} (deleting any existing wells first).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{geo}: \texttt{mulgrid}\\
  The geometry to copy wells from.
\end{itemize}

\subsubsection{\texttt{delete\_column(\emph{colname})}}

Deletes the column with the specified name from the grid.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{colname}: string\\
  Name of the column to be deleted.
\end{itemize}

\subsubsection{\texttt{delete\_connection(\emph{colnames})}}

Deletes the connection between the specified columns from the grid.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{colnames}: tuple of string\\
  Tuple of two column names.
\end{itemize}

\subsubsection{\texttt{delete\_layer(\emph{layername})}}

Deletes the layer with the specified name from the grid.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{layername}: string\\
  Name of the layer to be deleted.
\end{itemize}

\subsubsection{\texttt{delete\_orphans()}}

Deletes any orphaned nodes (those not belonging to any column) from the grid.

\subsubsection{\texttt{delete\_orphan\_wells()}}

Deletes any orphaned wells (those with wellheads outside the grid).

\subsubsection{\texttt{delete\_well(\emph{wellname})}}

Deletes the well with the specified name from the grid.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{layername}: string\\
  Name of the layer to be deleted.
\end{itemize}

\subsubsection{\texttt{empty()}}

Empties the grid of all its nodes, columns, layers, wells and connections.  Other properties are unaffected.

\subsubsection{\texttt{export\_surfer(\emph{filename}='', \emph{aspect}=8.0, \emph{left}=0.0)}}

Exports the grid to files on disk useful for visualization in Surfer.  Six files are written out:

\begin{itemize}
\item an Atlas BNA file (\texttt{filename.bna}) representing the grid columns
\item a CSV file (\texttt{filename\_column\_names.csv}) containing the column names
\item a Golden Software blanking file (\texttt{filename\_layers.bln}) file representing the grid layers
\item a CSV file (\texttt{filename\_layer\_bottom\_elevations.csv}) containing the bottom elevations of the layers
\item a CSV file (\texttt{filename\_layer\_centres.csv}) containing the elevations of the centres of the layers
\item a CSV file (\texttt{filename\_layer\_names.csv}) containing the names of the layers
\end{itemize}

\textbf{Parameters:}
\begin{itemize}
\item \textbf{filename}: string\\
  Base name for the exported files.  If it is not specified, the \texttt{filename} property of the \texttt{mulgrid} object itself is used (unless this is also blank, in which case a default name is used), with its extension removed.
\item \textbf{aspect}: float\\
  Aspect ratio for the layer plot, so that the width is the total height of the grid divided by \texttt{aspect} (default 8.0).
\item \textbf{left}: float\\
  Coordinate value of the left hand side of the layer plot (default zero).
\end{itemize}

\subsubsection{\texttt{fit\_surface(\emph{data}, \emph{alpha}=0.0, \emph{beta}=0.0, \emph{columns}=[], \emph{min\_columns}=[], \\
    \emph{grid\_boundary}=False, \emph{layer\_snap}=0.0)}}

Fits column surface elevations from data, using bilinear least-squares finite element fitting with Sobolev smoothing.  Smoothing is useful when data density is low in some areas of the grid, in which case least-squares fitting without smoothing can fail (e.g. if there are any columns which do not contain any data points).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{data}: \texttt{np.array}\\
  Two-dimensional array of data to fit.  Each row of the array should contain the x,y,z values for each data point.  Such an array can be conveniently read from a text file using the \texttt{np.loadtxt()} method.
\item \textbf{alpha}: float\\
  Smoothing parameter for first derivatives- increasing its value results in solutions with lower gradients (but may result in extrema being smoothed out).
\item \textbf{beta}: float\\
  Smoothing parameter for second derivatives- increasing its value results in solutions with lower curvature.
\item \textbf{columns}: list of string or \texttt{column}\\
  Columns, or names of columns to be fitted.  If empty (the default), then all columns will be fitted.
\item \textbf{min\_columns}: list of string or \texttt{column}\\
  Columns, or names of columns for which elevations will be determined from the minimum of the fitted nodal elevations (elevations at all other columns are determined from the average of the fitted nodal elevations).
\item \textbf{grid\_boundary}: Boolean\\
  If \texttt{True}, test each data point first to see if it lies inside the boundary polygon of the grid.  This can speed up the fitting process if there are many data points outside the grid, and the grid has a simple boundary (e.g. a rectangle).  In general if there are many data points outside the grid, it is best to clip the data set before fitting, particularly if it is to be used more than once.
\item \textbf{layer\_snap}: float\\
  Smallest desired surface block thickness.  Set to a positive value to prevent columns being assigned surface elevations that are very close to the bottom of a layer (resulting in very thin surface blocks).  Default value is zero (i.e. no layer snapping).
\end{itemize}

\subsubsection{\texttt{from\_gmsh(\emph{filename}, \emph{layers}, \emph{convention}=0, \emph{atmosphere\_type}=2,\\
    \emph{top\_elevation}=0)}}

Imports a 2-D \texttt{gmsh} mesh into a geometry object.  \texttt{gmsh} is grid generation program (see \texttt{http://geuz.org/gmsh/}).  The horizontal structure of the geometry object is created from the \texttt{gmsh} mesh, while the layer structure is specified via the \texttt{layers} parameter, a list of layer thicknesses.  The elevation of the top surface can also be specified, as well as the naming convention and atmosphere type.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{filename}: string\\
  Name of the \texttt{gmsh} mesh file.
\item \textbf{layers}: list\\
  List of floats containing the desired layer thicknesses.
\item \textbf{convention}: integer\\
  Naming convention for grid columns and layers.
\item \textbf{atmosphere\_type}: integer\\
  Type of atmosphere.
\item \textbf{top\_elevation}: float\\
  Elevation of the top surface of the model (default is zero).
\end{itemize}

\subsubsection{\texttt{layer\_containing\_elevation(\emph{elevation})}}

Returns the grid layer containing the specified vertical elevation.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{elevation}: float\\
  Vertical elevation
\end{itemize}

\subsubsection{\texttt{layer\_mapping(\emph{geo})}}

Returns a dictionary mapping each layer name in the \texttt{mulgrid} object \texttt{geo} to the name of the nearest layer in the object's own geometry.  (Note: this mapping takes no account of the grid surface, which may alter which layer is nearest in a given column.)

\textbf{Parameters:}
\begin{itemize}
\item \textbf{geo}: \texttt{mulgrid}\\
  The \texttt{mulgrid} object to create a layer mapping from.
\end{itemize}

\subsubsection{\texttt{layer\_name(\emph{block\_name})}}

Gives the name of the layer corresponding to the specified block name, according to the naming convention of the grid.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{block\_name}: string\\
  Block name.
\end{itemize}

\subsubsection{\texttt{layer\_plot(\emph{layer}, \emph{variable}=None, \emph{variable\_name}=None, \emph{unit}=None,\\
    \emph{column\_names}=None, \emph{node\_names}=None, \emph{column\_centres}=None, \emph{nodes}=None,\\
    \emph{colourmap}=None, \emph{linewidth}=0.2, \emph{linecolour}=`black', \emph{aspect}=`equal', \emph{plt}=None,\\
    \emph{subplot}=111, \emph{title}=None, \emph{xlabel}=`x (m)', \emph{ylabel}=`y (m)', \emph{contours}=False,\\
    \emph{contour\_label\_format}=`\%3.0f', \emph{contour\_grid\_divisions}=(100,100),\\
    \emph{connections}=None, \emph{colourbar\_limits}=None, \emph{plot\_limits}=None, \emph{wells}=None,\\
    \emph{well\_names}=True, \emph{hide\_wells\_outside}=True, \emph{wellcolour}=`blue', \emph{welllinewidth}=1.0,\\
    \emph{wellname\_bottom}=True)}}

Plots a variable over a layer of the grid, using the \texttt{matplotlib} plotting library.  The required layer can be specified by name or as an elevation (in which case the routine will find the corresponding layer).  Specifying the layer as \texttt{None} gives a plot over the ground surface of the geometry (i.e. the surface layer for each column).  The variable can be a list or \texttt{np.array} containing a value for every block (or column) in the grid.  If no variable is specified, only the grid in the layer is plotted, without shading.  If the variable contains a value for each column in the grid, these values are extended down each column to fill the entire grid.

The name and units of the variable can optionally be specified, and the names of the columns and nodes can also optionally be displayed on the plot, as well as the column centres (represented by crosses).  The colour map and limits of the variable shading, the line width of the grid columns and the aspect ratio of the plot can also be set, as can the title and x- and y-axis labels, and the plot limits.

When a variable is plotted over the grid, contours at specified levels can also be drawn, and optionally labelled with their values.

Well tracks can also optionally be plotted.  Each well is drawn as a line following the well track, with the well name at the bottom (or optionally the top) of the well.  For surface plots (\texttt{layer} = \texttt{None}), wells are drawn with solid lines; otherwise, wells are drawn with dotted lines except where they pass through the specified layer, where they are drawn with solid lines.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{layer}: string, integer, float or \texttt{None}\\
  Name (string) of layer to plot, or elevation (float or integer).  Specifying \texttt{None} gives a surface plot.
\item \textbf{variable}: list (or \texttt{np.array})\\
  Variable to be plotted, of length equal to the number of blocks or columns in the grid (or \texttt{None} just to plot the grid).
\item \textbf{variable\_name}: string\\
  Name of the variable (as it will appear on the scale of the plot).
\item \textbf{unit}: string\\
  Units of the variable (as it will appear on the scale of the plot).
\item \textbf{column\_names}: Boolean or list\\
  Set to \texttt{True} if column names are to be indicated on the plot, or to a list of names of columns to be named.
\item \textbf{node\_names}: Boolean or list\\
  Set to \texttt{True} if node names are to be indicated on the plot, or to a list of names of nodes to be named.
\item \textbf{column\_centres}: Boolean or list\\
  Set to \texttt{True} if column centres are to be indicated on the plot (as crosses), or to a list of names of columns to be indicated.
\item \textbf{nodes}: Boolean or list\\
  Set to \texttt{True} if nodes are to be indicated on the plot (as crosses), or to a list of names of nodes to be indicated.
\item \textbf{colourmap}: string\\
  Name of \texttt{matplotlib} colour map to use for shading the variable.
\item \textbf{linewidth}: float\\
  Line width to use for drawing the grid.
\item \textbf{linecolour}: string\\
  Line colour to use for drawing the grid.
\item \textbf{aspect}: string\\
  Aspect ratio to use for drawing the grid (default is `equal' (i.e. 1:1).
\item \textbf{plt}: \texttt{matplotlib.pyplot} instance\\
  An instance of the \texttt{matplotlib.pyplot} library, imported in the calling script using e.g. \texttt{import matplotlib.pyplot as plt}.
\item \textbf{subplot}: integer\\
  Subplot number for multi-plots, e.g. set 223 to draw the third plot in a 2-by-2 multiplot (default is 111).
\item \textbf{title}: string\\
  Plot title.  If set to \texttt{None} (the default value), a title will be constructed from the other plot parameters.  Set to `' for no title.
\item \textbf{xlabel}: string\\
  x axis label (default is `x (m)').
\item \textbf{ylabel}: string\\
  y axis label (default is `y (m)').
\item \textbf{contours}: Boolean, list or \texttt{np.array}\\
  Set to \texttt{True} or to a list or array of contour values to draw contours on the plot (default \texttt{False}).
\item \textbf{contour\_label\_format}: string\\
  Format string for contour labels (default `\%3.0f').
\item \textbf{contour\_grid\_divisions}: tuple (of integer)\\
  Number of divisions in the x- and y-directions in the regular grid superimposed on the model grid, and used to produce the contours (default (100,100)).
\item \textbf{connections}: float (or \texttt{None})\\
  Set non-zero to plot connections in the grid, shaded by absolute value of the connection angle cosine.  The value specifies the lower cut-off value, above which connections will be plotted.  Connections are shaded in greyscale from white (0.0) to black (1.0).  This can be used to check orthogonality of grid connections, as less orthogonal connections (with larger angle cosine) will show up darker on the plot.  If set to \texttt{None}, no connections will be plotted.
\item \textbf{colourbar\_limits}: tuple, list, \texttt{np.array} (or \texttt{None})\\
  Specify a two-element tuple, list or \texttt{np.array} to set the limits of the colour scale.  Default (\texttt{None}) will auto-scale.
\item \textbf{plot\_limits}: tuple or list (or \texttt{None})\\
  Specify a two-element tuple (or list) of plot axis ranges, each itself being a tuple (or list) of minimum and maximum values, i.e. ((xmin,xmax),(ymin,ymax)).  Default is \texttt{False} which will auto-scale.
\item \textbf{wells}: Boolean or list (or \texttt{None})\\
  Specify \texttt{True} to plot all well tracks, \texttt{False} or \texttt{None} not to plot them, or a list of wells or well names to specify only particular wells.
\item \textbf{well\_names}: Boolean or list (or \texttt{None})\\
  Specify \texttt{True} to label each well with its name , \texttt{False} or \texttt{None} not to label them, or a list of wells or well names to label only particular wells.
\item \textbf{hide\_wells\_outside}: Boolean\\
  Set to \texttt{True} if wells that do not intersect the specified layer are to be hidden.
\item \textbf{wellcolour}: string\\
  Colour to use for drawing the wells.
\item \textbf{welllinewidth}: float\\
  Line width for drawing the wells.
\item \textbf{wellname\_bottom}: Boolean\\
  Set to \texttt{False} to label wells at the wellhead rather than the bottom.
\end{itemize}

\textbf{Example:}

\begin{verbatim}
geo.layer_plot(-500.,t,`Temperature',`$^o$C', contours=np.arange(100,200,25))
\end{verbatim}

plots the variable \texttt{t} at elevation -500 m over the grid, with the values as Temperature ($^{\circ}$C), and with contours drawn from 100$^o$C to 200$^o$C with a contour interval of 25$^o$C.

\subsubsection{\texttt{line\_values(\emph{start}, \emph{end}, \emph{variable}, \emph{divisions}=100, \emph{coordinate}=\texttt{False}, \emph{qtree}=None)}}

Returns values of a specified variable along an arbitrary line through the grid.  The start and end points of the line (\texttt{start} and \texttt{end}) are 3-element lists, tuples or \texttt{np.arrays} specifying points in 3D.  The variable can be a list or \texttt{np.array} containing a value for every block in the grid.  The number of divisions along the line (default 100) can be optionally specified.

The routine returns a tuple of two arrays (\emph{l},\emph{v}), the first (\emph{l}) containing the distance from the start (or the appropriate coordinate (0,1, or 2) if \texttt{coordinate} is specified) for each point along the line, and the second (\emph{v}) containing the value of the variable at that point.  The value of the variable at any point is the (block average) value at the block containing the point.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{start}, \textbf{end}: list, tuple or \texttt{np.array} (of length 3)\\
  Start and end points of the line in 3D.
\item \textbf{variable}: list (or \texttt{np.array})\\
  Variable to be plotted, of length equal to the number of blocks in the grid.
\item \textbf{divisions}: integer\\
  Number of segments the line is divided up into (default 100).
\item \textbf{coordinate}: integer or Boolean\\
  If \texttt{False}, return distance along the line in first array, otherwise return specified coordinate (0,1 or 2) values.
\item \textbf{qtree}: \texttt{quadtree}\\
  Quadtree object for fast searching of grid columns (can be constructed using the \texttt{column\_quadtree()} method).
\end{itemize}

\subsubsection{\texttt{line\_plot(\emph{start}=None, \emph{end}=None, \emph{variable}, \emph{variable\_name}=None,\\
\emph{unit}=None, \emph{divisions}=100, \emph{plt}=None, \emph{subplot}=111, \emph{title}=`',\\
\emph{xlabel}=`distance (m)')}}

Plots a variable along a line through the grid, using the \texttt{matplotlib} plotting library. The line is specified by its start and end points in 3D.  The variable can be a list or \texttt{np.array} containing a value for every block (or column) in the grid.  If the variable contains a value for each column in the grid, these values are extended down each column to fill the entire grid.  The name and units of the variable can optionally be specified, as well as the number of divisions the line is divided into (default 100), the plot title and the axis labels.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{start}, \textbf{end}: list, tuple or \texttt{np.array}\\
  Start and end point of the line, each of length 3 (\texttt{None} to plot across the bounds of the grid).
\item \textbf{variable}: list (or \texttt{np.array})\\
  Variable to be plotted, of length equal to the number of blocks (or columns) in the grid.
\item \textbf{variable\_name}: string\\
  Name of the variable (as it will appear on the scale of the plot).
\item \textbf{unit}: string\\
  Units of the variable (as it will appear on the scale of the plot).
\item \textbf{divisions}: integer\\
  Number of divisions to divide the line into (default 100).
\item \textbf{plt}: \texttt{matplotlib.pyplot} instance\\
  An instance of the \texttt{matplotlib.pyplot} library, imported in the calling script using e.g. \texttt{import matplotlib.pyplot as plt}.
\item \textbf{subplot}: integer\\
  Subplot number for multi-plots, e.g. set 223 to draw the third plot in a 2-by-2 multiplot (default is 111).
\item \textbf{title}: string\\
  Plot title.  If set to \texttt{None} (the default value), a title will be constructed from the other plot parameters.  Set to `' for no title.
\item \textbf{xlabel}: string\\
  x axis label (default is `distance (m)').
\end{itemize}

\textbf{Example:}

\begin{verbatim}
geo.line_plot([0.,0.,500.],[1000.,0.,500.],t,`Temperature',`$^o$C')
\end{verbatim}

plots the variable \texttt{t} along a line from (0,0,500) to (1000,0,500) through the grid, with the values as Temperature ($^{\circ}$C).

\subsubsection{\texttt{nodes\_in\_columns(\emph{columns})}}

Returns a list of all nodes in a specified list of columns.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{columns}: list (of \texttt{column})\\
  List of columns in which to find nodes.
\end{itemize}

\subsubsection{\texttt{nodes\_in\_polygon(\emph{polygon})}}

Returns a list of all nodes inside the specified polygon or rectangle.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{polygon}: list (of \texttt{np.array})\\
  List of points defining the polygon (each point is a two-element \texttt{np.array}).  If the list has only two points, it will be interpreted as a rectangle [bottom left, top right].
\end{itemize}

\subsubsection{\texttt{node\_nearest\_to(\emph{point}, \emph{kdtree}=None)}}

Returns the node nearest to a specified point.  An optional kd-tree structure can be specified to speed searching- useful if searching for many points.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{point}:  \texttt{np.array}, list or tuple\\
  Array or list of length 2, specifying the required point in 2-D.
\item \textbf{kdtree}:  \texttt{cKDTree}\\
  kd-tree structure for searching for nodes.  Such a tree can be constructed using the \texttt{node\_kdtree} property of a \texttt{mulgrid} object.  You will need the \texttt{scipy} library installed before you can use this property.
\end{itemize}

\subsubsection{\texttt{optimize(\emph{nodenames}=None, \emph{connection\_angle\_weight}=1.0, \emph{column\_aspect\_weight}=0.0,\\
    \emph{column\_skewness\_weight}=0.0, \emph{pest}=False)}}

Adjusts positions of the specified nodes to optimize grid quality.  If no nodes are specified, all node positions are optimized.  Grid quality can be defined as a combination of connection angle cosine, column aspect ratio and column skewness.  Increasing the weight for any of these increases its importance in the evaluation of grid quality.

Note that an error will result if the connection angle weight and either of the other two weights is set to zero- in this case there are not enough constraints to fit the parameters.

If the \texttt{pest} parameter is set to \texttt{True}, the PEST parameter estimation software is used to carry out the optimzation (this obviously requires that PEST is installed on your machine).  Otherwise, the \texttt{leastsq} routine in the \texttt{scipy} Python library is used.  Particularly for large problems, PEST may give quicker results.  PEST is free software and may be downloaded from \texttt{http://www.pesthomepage.org/}.  If PEST is used, a variety of intermediate files (named \texttt{pestmesh.*}) will be written to the working directory, including the PEST run record file (\texttt{pestmesh.rec}) which contains a detailed record of the optimization process.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{nodenames}: list of string\\
  List of names of nodes to optimize.  If not specified, all nodes in the grid are optimized.
\item \textbf{connection\_angle\_weight}: float\\
  Weighting to be given to connection angle cosines.  A higher value will place greater priority on making connections perpendicular to the column sides.
\item \textbf{column\_aspect\_weight}: float\\
  Weighting to be given to column aspect ratios.  A higher value will place greater priority on making column side ratios closer to 1.0.
\item \textbf{column\_skewness\_weight}: float\\
  Weighting to be given to column skewness.  A higher value will place greater priority on making column angle ratios closer to 1.0.
\item \textbf{pest}: Boolean\\
  Set \texttt{True} to use the PEST parameter estimation software to perform the optimization.
\end{itemize}

\subsubsection{\texttt{polyline\_values(\emph{polyline}, \emph{variable}, \emph{divisions}=100, \emph{coordinate}=\texttt{False}, \emph{qtree}=None)}}

Returns values of a specified variable along an arbitrary polyline through the grid, defined as a list of 3-element lists or \texttt{np.arrays} specifying points in 3D.  The variable can be a list or \texttt{np.array} containing a value for every block in the grid.  The number of divisions along the line (default 100) can be optionally specified.

The routine returns a tuple of two arrays (\texttt{l},\texttt{v}), the first (\texttt{l}) containing the distance from the start (or the appropriate coordinate (0, 1, or 2) if \texttt{coordinate} is specified) for each point along the polyline, and the second (\texttt{v}) containing the value of the variable at that point.  The value of the variable at any point is the (block average) value at the block containing the point.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{polyline}: list of 3-element lists or \texttt{np.arrays}\\
  Polyline points in 3D.
\item \textbf{variable}: list (or \texttt{np.array})\\
  Variable to be plotted, of length equal to the number of blocks in the grid.
\item \textbf{divisions}: integer\\
  Number of segments the line is divided up into (default 100).
\item \textbf{coordinate}: integer or Boolean\\
  If \texttt{False}, return distance along the line in first array, otherwise return specified coordinate (0, 1 or 2) values.
\item \textbf{qtree}: \texttt{quadtree}\\
  Quadtree object for fast searching of grid columns (can be constructed using the \texttt{column\_quadtree()} method).
\end{itemize}

\subsubsection{\texttt{read(\emph{filename})}}

Reads a \texttt{mulgrid} object from a MULgraph geometry file on disk.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{filename}: string\\
  Name of the MULgraph geometry file to be read.
\end{itemize}

\textbf{Example:}

\begin{verbatim}
geo=mulgrid().read(filename)
\end{verbatim}

creates a \texttt{mulgrid} object and reads its contents from file \texttt{filename}.  This can be done more simply just by passing the filename into the \texttt{mulgrid} creation command:

\begin{verbatim}
geo=mulgrid(filename)
\end{verbatim}

\subsubsection{\texttt{rectangular(\emph{xblocks}, \emph{yblocks}, \emph{zblocks}, \emph{convention}=0, \emph{atmos\_type}=2,\\
    \emph{origin}=[0,0,0], \emph{justify}=`r', \emph{case}=`l')}}

Gives a \texttt{mulgrid} geometry object a rectangular grid structure.  The grid sizes in the \emph{x}, \emph{y} and \emph{z} directions can be non-uniform, and the grid column and layer naming convention, atmosphere type and origin can be specified.  The optional \texttt{justify} and \texttt{case} parameters control the formatting of the character part of the block names.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{xblocks}, \textbf{yblocks}, \textbf{zblocks}: list, tuple or \texttt{np.array}\\
  Lists (or arrays) of block sizes in the \emph{x}, \emph{y} and \emph{z} directions.
\item \textbf{convention}: integer\\
  Naming convention for grid columns and layers.
\item \textbf{atmos\_type}: integer\\
  Type of atmosphere.
\item \textbf{origin}: list (or \texttt{np.array})\\
  Origin of the grid (of length 3).
\item \textbf{justify}: string\\
  Specify `r' for the character part of the block names (first three characters) to be right-justified, `l' for left-justified.
\item \textbf{case}: string\\
  Specify `l' for the character part of the block names (first three characters) to be lower case, `u' for upper case.
\end{itemize}

\textbf{Example:}

\begin{verbatim}
geo=mulgrid().rectangular([1000]*10,[500]*20,[100]*5+[200]*10,
  origin=[0,0,2500])
\end{verbatim}

creates a \texttt{mulgrid} object called \texttt{geo}, and fills it with a rectangular grid of 10 blocks of size 1000 m in the \emph{x}-direction, 20 blocks of size 500 m in the \emph{x}-direction, 5 layers at the top of thickness 100 m and 10 layers underneath of thickness 200 m, and with origin (0,0,2500) m.  The grid will have the default naming convention (0) and atmosphere type (2).

\subsubsection{\texttt{reduce(\emph{columns})}}

Reduces a grid so that it contains only the specified list of columns (or columns with specified names).

\textbf{Parameters:}
\begin{itemize}
  \item \textbf{columns}: list\\
    List of required columns or column names.
\end{itemize}

\subsubsection{\texttt{refine(\emph{columns}=[], \emph{bisect}=False, \emph{bisect\_edge\_columns}=[])}}

Refines the specified columns in the grid.  Appropriate transition columns are created around the refined region.  If no columns are specified, all columns are refined.  All columns in the region to be refined (and in the transition region) must be either triangular or quadrilateral.  Each column in split into four, unless the \texttt{bisect} parameter is \texttt{True}, in which case each column in split into two.  If \texttt{bisect} is `x' or `y', columns are split in the closest direction to the axis specified; or if \texttt{bisect} is \texttt{True}, between its longest sides.

The \texttt{bisect\_edge\_columns} parameter can be used to give more desirable column shapes in the transition region, if the original columns occupying the transition region have large aspect ratios.  By default, these will become even worse when they are triangulated to form the transition columns, if they are connected to the refinement region by their shorter sides.  Including them in \texttt{bisect\_edge\_columns} means they will be bisected (parallel to the edge of the refinement region) before the refinement is carried out, which should improve the aspect ratios of the transition columns.

\textbf{Parameters:}
\begin{itemize}
  \item \textbf{columns}: list\\
    List of columns or column names to be refined.
  \item \textbf{bisect}: Boolean or string\\
    Set to \texttt{True} if columns are to be split into two, between their longest sides, instead of four (the default).  Set to `x' or `y' to split columns along the specified axis.
  \item \textbf{bisect\_edge\_columns}: list\\
    List of columns or column names in the transition region (just outside the refinement area) to be bisected prior to the refinement, to improve the aspect ratios of the transition columns.
\end{itemize}

\subsubsection{\texttt{refine\_layers(\emph{layers}=[], \emph{factor}=2)}}

Refines the specified layers in the grid.  If no layers are specified, all layers are refined.  Each layer is refined by the specified integer factor.

\textbf{Parameters:}
\begin{itemize}
  \item \textbf{layers}: list\\
    List of layers or layer names to be refined.
  \item \textbf{factor}: integer\\
    Refinement factor: default is 2, which bisects each layer.
\end{itemize}

\subsubsection{\texttt{rename\_column(\emph{oldcolname}, \emph{newcolname})}}

Renames a grid column.  Returns \texttt{True} if the column was found and renamed, or \texttt{False} if the specified column does not exist.

\textbf{Parameters:}
\begin{itemize}
  \item \textbf{oldcolname}: string\\
    Name of the column to rename.
  \item \textbf{newcolname}: string\\
    New name of the column.
\end{itemize}

\subsubsection{\texttt{rename\_layer(\emph{oldlayername}, \emph{newlayername})}}

Renames a grid layer.  Returns \texttt{True} if the layer was found and renamed, or \texttt{False} if the specified layer does not exist.

\textbf{Parameters:}
\begin{itemize}
  \item \textbf{oldlayername}: string\\
    Name of the layer to rename.
  \item \textbf{newlayername}: string\\
    New name of the layer.
\end{itemize}

\subsubsection{\texttt{rotate(\emph{angle}, \emph{centre}=\texttt{None}, \emph{wells}=\texttt{False})}}

Rotates a grid by a specified angle (in degrees) clockwise in the horizontal plane.  Any wells in the grid are also rotated.  The centre of rotation can be optionally specified.  If it is not specified, the centre of the grid is used as the centre of rotation.  If the \texttt{wells} parameter is \texttt{True}, any wells in the grid are also rotated.

\textbf{Parameters:}
\begin{itemize}
  \item \textbf{angle}: float\\
    Angle (in degrees) to rotate the grid, positive for clockwise, negative for anti-clockwise.
  \item \textbf{centre}: list, tuple or \texttt{np.array}\\
    Centre of rotation in the horizontal \emph{x},\emph{y} plane (of length 2).
  \item \textbf{wells}: Boolean\\
    Set \texttt{True} to rotate wells.
\end{itemize}

\textbf{Example:}

\begin{verbatim}
geo.rotate(30)
\end{verbatim}

rotates the grid \texttt{geo} clockwise by 30$^{\circ}$ about its centre in the horizontal plane.

\subsubsection{\texttt{slice\_plot(\emph{line}=None, \emph{variable}=None, \emph{variable\_name}=None, \emph{unit}=None,\\
    \emph{block\_names}=None, \emph{colourmap}=None, \emph{linewidth}=0.2, \emph{linecolour}=`black', \emph{aspect}=`auto',\\
    \emph{plt}=None, \emph{subplot}=111, \emph{title}=None, \emph{xlabel}=`', \emph{ylabel}=`elevation (m)',\\
    \emph{contours}=False, \emph{contour\_label\_format}=`\%3.0f', \emph{contour\_grid\_divisions}=(100,100),\\
    \emph{colourbar\_limits}=None, \emph{plot\_limits}=None, \emph{column\_axis}=False, \emph{layer\_axis}=False,\\
    \emph{wells}=None, \emph{well\_names}=True, \emph{hide\_wells\_outside}=False, \emph{wellcolour}=`blue',\\
    \emph{welllinewidth}=1.0, \emph{wellname\_bottom}=True))}}

Plots a variable over a vertical slice through the grid, using the \texttt{matplotlib} plotting library.  The required slice is specified by a horizontal line through the grid, defined as either a two-element list of (\emph{x},\emph{y}) points (\texttt{np.arrays}), or as a string `x' or `y' which defines the \emph{x}- or \emph{y}-axes respectively, or as a northing (in degrees) through the centre of the grid.  If no line is specified, the line is taken to be across the bounds of the grid.  For slice plots along the x- or y-axis, the horizontal coordinate represents the x- or y-coordinate; for other slice directions it represents distance along the slice line.

The variable can be a list or \texttt{np.array} containing a value for every block (or column) in the grid.  If no variable is specified, only the grid is plotted, without shading.  If the variable contains a value for each column in the grid, these values are extended down each column to fill the entire grid.

The name and units of the variable can optionally be specified, and the name of each block can also optionally be displayed on the plot.  The colour map and limits of the variable shading, the line width of the grid columns and the aspect ratio of the plot can also be set, as can the plot title and x- and z-axis labels, and the plot limits.

When a variable is plotted over the grid, contours at specified levels can also be drawn, and optionally labelled with their values.

Well tracks can also optionally be plotted.  Each well is drawn as a line following the well track, with the well name at the bottom (or optionally the top) of the well.  If \texttt{hide\_wells\_outside} is specified as a floating point number, wells that do not pass within the specified distance from the slice line are not shown.  Well tracks are shown as solid lines over sections within the specified distance from the slice line, and dotted lines otherwise.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{line}: list, string or float\\
  List of two horizontal (\emph{x},\emph{y}) points (\texttt{np.arrays}) defining the endpoints of the line, or string `x' or `y' to specify the \emph{x}- or \emph{y}-axis, or northing (float) through grid centre.
\item \textbf{variable}: list (or \texttt{np.array})\\
  Variable to be plotted, of length equal to the number of blocks (or columns) in the grid (or \texttt{None} just to plot the grid).
\item \textbf{variable\_name}: string\\
  Name of the variable (as it will appear on the scale of the plot).
\item \textbf{unit}: string\\
  Units of the variable (as it will appear on the scale of the plot).
\item \textbf{block\_names}: Boolean or list\\
  Set to \texttt{True} if block names are to be indicated on the plot, or to a list of names of blocks to be named.
\item \textbf{colourmap}: string\\
  Name of \texttt{matplotlib} colour map to use for shading the variable.
\item \textbf{linewidth}: float\\
  Line width to use for drawing the grid.
\item \textbf{linecolour}: string\\
  Line colour to use for drawing the grid.
\item \textbf{aspect}: string\\
  Aspect ratio to use for drawing the grid (default is `auto').
\item \textbf{plt}: \texttt{matplotlib.pyplot} instance\\
  An instance of the \texttt{matplotlib.pyplot} library, imported in the calling script using e.g. \texttt{import matplotlib.pyplot as plt}.
\item \textbf{subplot}: integer\\
  Subplot number for multi-plots, e.g. set 223 to draw the third plot in a 2-by-2 multiplot (default is 111).
\item \textbf{title}: string\\
  Plot title.  If set to \texttt{None} (the default value), a title will be constructed from the other plot parameters.  Set to `' for no title.
\item \textbf{xlabel}: string\\
  x axis label.  If set to \texttt{None} (the default value), a label will be constructed according to the slice orientation- either `x (m)', `y (m)' or `distance (m)' as appropriate.
\item \textbf{ylabel}: string\\
  y axis label (default is `elevation (m)').
\item \textbf{contours}: Boolean, list or \texttt{np.array}\\
  Set to \texttt{True} or to a list or array of contour values to draw contours on the plot (default \texttt{False}).
\item \textbf{contour\_label\_format}: string\\
  Format string for contour labels (default `\%3.0f').
\item \textbf{contour\_grid\_divisions}: tuple (of integer)\\
  Number of divisions in the x- and z-directions in the regular grid superimposed on the slice, and used to produce the contours (default (100,100)).
\item \textbf{colourbar\_limits}: tuple, list, \texttt{np.array} (or \texttt{None})\\
  Specify a two-element tuple, list or \texttt{np.array} to set the limits of the colour scale.  Default (\texttt{None}) will auto-scale.
\item \textbf{plot\_limits}: tuple or list (or \texttt{None})\\
  Specify a two-element tuple (or list) of plot axis ranges, each itself being a tuple (or list) of minimum and maximum values, i.e. ((xmin,xmax),(zmin,zmax)).  Default is \texttt{False} which will auto-scale.
\item \textbf{column\_axis}: Boolean\\
  If \texttt{True}, show column names instead of coordinates on the horizontal axis.
\item \textbf{layer\_axis}: Boolean\\
  If \texttt{True}, show layer names instead of coordinates on the vertical axis.
\item \textbf{wells}: Boolean or list (or \texttt{None})\\
  Specify \texttt{True} to plot all well tracks, \texttt{False} or \texttt{None} not to plot them, or a list of wells or well names to specify only particular wells.
\item \textbf{well\_names}: Boolean or list (or \texttt{None})\\
  Specify \texttt{True} to label each well with its name , \texttt{False} or \texttt{None} not to label them, or a list of wells or well names to label only particular wells.
\item \textbf{hide\_wells\_outside}: \texttt{False} or float\\
  Specify distance as a floating point number to hide wells further from the slice line than the specified distance.
\item \textbf{wellcolour}: string\\
  Colour to use for drawing the wells.
\item \textbf{welllinewidth}: float\\
  Line width for drawing the wells.
\item \textbf{wellname\_bottom}: Boolean\\
  Set to \texttt{False} to label wells at the wellhead rather than the bottom.
\end{itemize}

\textbf{Example:}

\begin{verbatim}
geo.slice_plot(45.,t,`Temperature',`$^o$C',contours=[100,200])
\end{verbatim}

plots the variable \texttt{t} through a SW--NE vertical slice (heading 45$^{\circ}$) through the grid, with the values as Temperature ($^{\circ}C$) and contours drawn at 100$^o$C and 200$^o$C.

\subsubsection{\texttt{snap\_columns\_to\_layers(\emph{min\_thickness}=1.0, \emph{columns}=[])}}

Snaps column surfaces to the bottom of their layers, if the surface block thickness is smaller than a given value.  This can be carried out over an optional subset of columns in the grid, otherwise over all columns.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{min\_thickness}: float\\
  Minimum surface block thickness.  Blocks with thickness less than this value will be eliminated by `snapping' the column surface elevation to the bottom of the surface layer.  Values of \texttt{min\_thickness} less than or equal to zero will have no effect.
\item \textbf{columns}: list\\
  List of columns to process.  If empty (the default), process all columns.
\end{itemize}

\subsubsection{\texttt{split\_column(\emph{colname}, \emph{nodename})}}

Splits a quadrilateral column with specified name into two triangular columns.  The direction of the split is determined
by specifying the name of one of the splitting nodes.  The method returns \texttt{True} if the split was carried out successfully.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{colname}: string\\
  Name of the quadrilateral column to be split.  If the column is not quadrilateral, the method returns \texttt{False} and nothing is done to the column.
\item \textbf{nodename}: string\\
  Name of one of the splitting nodes.  The column is split across this node and the one on the opposite side of the column.  If the specified node is not in the column, the method returns \texttt{False} and nothing is done to the column.
\end{itemize}

\subsubsection{\texttt{translate(\emph{shift}, \emph{wells}=\texttt{False})}}

Translates a grid by a specified shift in the \emph{x}, \emph{y} and \emph{z} directions.  If the \texttt{wells} parameter is \texttt{True}, any wells in the grid are also translated.

\textbf{Parameters:}
\begin{itemize}
  \item \textbf{shift}: list, tuple or \texttt{np.array}\\
    Distance to shift the grid in the \emph{x}, \emph{y} and \emph{z} directions (of length 3).
  \item \textbf{wells}: Boolean\\\
    Set \texttt{True} to translate wells.
\end{itemize}

\textbf{Example:}

\begin{verbatim}
geo.translate([10.e3,0.0,-1000.0])
\end{verbatim}

translates the grid \texttt{geo} by 10 km in the \emph{x} direction and down 1 km in the \emph{z} direction.

\subsubsection{\texttt{well\_values(\emph{well\_name}, \emph{variable}, \emph{divisions}=1, \emph{elevation}=\texttt{False}, \\
    \emph{deviations}=\texttt{False}, \emph{qtree}=None, \emph{extend}=\texttt{False})}}

Returns values of a specified variable down a specified well.  The variable can be a list or \texttt{np.array} containing a value for every block in the grid.  The number of divisions between layer centres or along each well deviation (default 1) can be optionally specified (this can be increased to capture detail along a deviation that passes through several blocks).  If \texttt{deviations} is \texttt{True}, values will be returned at the nodes of the well track, instead of at grid layer centres.  If \texttt{extend} is \texttt{True}, the well trace is artificially extended to the bottom of the model.

The routine returns a tuple of two arrays (\texttt{d},\texttt{v}), the first (\texttt{d}) containing the measured depth down the well (or elevation if the \texttt{elevation} parameter is set to \texttt{True}), and the second (\texttt{v}) containing the value of the variable at each point.  The value of the variable at any point is the (block average) value at the block containing the point.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{well\_name}: string\\
  Name of the well.
\item \textbf{variable}: list (or \texttt{np.array})\\
  Variable to be plotted, of length equal to the number of blocks in the grid.
\item \textbf{divisions}: integer\\
  Number of divisions each well deviation is divided up into (default 1).
\item \textbf{elevation}: Boolean\\
  Set to \texttt{True} if elevation rather than measured depth is to be returned.
\item \textbf{deviations}: Boolean\\
  Set to \texttt{True} to return values at deviation nodes, rather than intersections of layer centres with the well track.
\item \textbf{qtree}: \texttt{quadtree}\\
  Quadtree object for fast searching of grid columns (can be constructed using the \texttt{column\_quadtree()} method).
\item \textbf{extend}: Boolean\\
  Set \texttt{True} to artificially extend the well trace to the bottom of the model.
\end{itemize}

\subsubsection{\texttt{write(\emph{filename}=`')}}

Writes a \texttt{mulgrid} object to a MULgraph geometry file on disk.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{filename}: string\\
  Name of the MULgraph geometry file to be written.  If no file name is specified, the object's own \texttt{filename} property is used.
\end{itemize}

\subsubsection{\texttt{write\_bna(\emph{filename}=`')}}

Writes a geometry object to an Atlas BNA file on disk, for visualisation with Surfer or GIS tools.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{filename}: string\\
  Name of the BNA file to be written.  If no file name is specified, the object's own \texttt{filename} property is used, with the extension changed to *.bna.  If the object's \texttt{filename} property is not set, the default name `geometry.bna' is used.
\end{itemize}

\subsubsection{\texttt{write\_vtk(\emph{filename}=`', \emph{arrays}=None, \emph{wells}=False)}}

Writes a \texttt{mulgrid} object to a VTK file on disk, for visualisation with VTK, Paraview, Mayavi etc.  The grid is written as an `unstructured grid' VTK object with optional data arrays defined on cells.  A separate VTK file for the wells in the grid can optionally be written.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{filename}: string\\
  Name of the VTK file to be written.  If no file name is specified, the object's own \texttt{filename} property is used, with the extension changed to *.vtu.  If the object's \texttt{filename} property is not set, the default name `geometry.vtu' is used.
\item \textbf{arrays}: dictionary or \texttt{None}\\
  Data arrays to be included in the VTK file.  If set to \texttt{None}, default arrays (layer index, column index, column area, column elevation, block number and volume) are included.
\item \textbf{wells}: Boolean\\
  If set to \texttt{True}, a separate VTK file is written representing the wells in the grid.
\end{itemize}

\section{Other objects (\texttt{node}, \texttt{column}, \texttt{layer}, \texttt{connection} and \texttt{well})}
\label{other_mulgrid_objects}

A \texttt{mulgrid} object contains lists of other types of objects: \texttt{node}, \texttt{column}, \texttt{layer}, \texttt{connection} and \texttt{well} objects.  These classes are described below.

\subsection{\texttt{node} objects}

A \texttt{node} object represents a node (i.e. vertex) in a \texttt{mulgrid} object.  A \texttt{node} object has three properties: \texttt{name}, which is a string property containing the name of the node, \texttt{pos} which is an \texttt{np.array} with three elements, containing the node's position in 3D, and \texttt{column} which is a set of the columns the node belongs to.  A \texttt{node} object does not have any methods.

A \texttt{node} object \texttt{n} can be created for example using the command \texttt{n = node(name,pos)} where \texttt{name} is the node name and pos is an \texttt{np.array} (or list, or tuple) representing the node's position.

\subsection{\texttt{column} objects}
\label{columnobjects}

A \texttt{column} object represents a column in a \texttt{mulgrid} object.  The properties of a \texttt{column} object are listed in Table \ref{tb:column_properties}.

The main properties defining a column are its \texttt{name} and \texttt{node} properties.  The \texttt{name} is specified according to the naming convention of the \texttt{mulgrid} object that the column belongs to.  The \texttt{node} property is a list of \texttt{node} objects (not node names) that belong to the column.  A \texttt{column}'s \texttt{neighbour} property is a set of other \texttt{columns} connected to that column via a \texttt{connection} (see section \ref{connections}), and its \texttt{connection} property is a set of connections the column is part of.  The \texttt{neighbourlist} property is a list of neighbouring columns, with each item corresponding to a column edge (\texttt{None} if the edge is on a grid boundary).  A \texttt{column}'s \texttt{centroid} property returns the average of the positions of its vertices- which is what the \texttt{centre} property is set to, unless otherwise specified.

A \texttt{column} object has two properties measuring `grid quality'.  The \texttt{angle\_ratio} property returns the ratio of largest to smallest interior angles in the column.  The \texttt{side\_ratio} property returns the ratio of largest to smallest side lengths (a generalisation of `aspect ratio' to columns with any number of sides).  Values as close as possible to 1.0 for both these measures are desirable (their values are both exactly 1.0 for any regular polygon, e.g. an equilateral triangle or square).  Columns with large angle ratios will be highly skewed, while those with large side ratios will be typically highly elongated in one direction.

A \texttt{column} object \texttt{col} can be created for example using the command \texttt{col = column(name,nodes,centre,surface)} where \texttt{name} is the column name and \texttt{nodes} is a list of \texttt{node} objects defining the column.  The \texttt{centre} and \texttt{surface} parameters are optional.

\texttt{column} objects have three methods, \texttt{contains\_point}, \texttt{in\_polygon} and \texttt{is\_against}, as described below.

\subsubsection{\texttt{contains\_point(\emph{pos})}}

Returns \texttt{True} if a 2D point lies inside the column, and \texttt{False} otherwise.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{pos}: \texttt{np.array}\\
  Horizontal position of the point.
\end{itemize}

\subsubsection{\texttt{in\_polygon(\emph{polygon})}}

Returns \texttt{true} if the column centre is inside the specified polygon or rectangle.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{polygon}: list (of \texttt{np.array})\\
  List of points defining the polygon (each point is a two-element \texttt{np.array}).  If the list has only two points, it will be interpreted as a rectangle [bottom left, top right].
\end{itemize}

\subsubsection{\texttt{is\_against(\emph{othercolumn})}}

Returns \texttt{true} if the column is `against' \texttt{othercolumn}- that is, if it shares more than one node with it.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{othercolumn}: \texttt{column})\\
  Any other column in the geometry.
\end{itemize}

\begin{table}
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Property} & \textbf{Type} & \textbf{Description}\\
      \hline
      \texttt{angle\_ratio} & float & ratio of largest to smallest interior angles \\
      \texttt{area} & float & horizontal area of the column \\
      \texttt{centre} & \texttt{np.array} & horizontal centre of the column \\
      \texttt{centroid} & \texttt{np.array} & average position of the column's vertices \\
      \texttt{connection} & set & connections the column is in \\
      \texttt{name} & string & name of the column \\
      \texttt{neighbour} & set & set of neighbouring columns \\
      \texttt{neighbourlist} & list & ordered list of neighbouring columns \\
      \texttt{node} & list & list of nodes (vertices) belonging to the column \\
      \texttt{num\_neighbours} & integer & number of neighbouring columns \\
      \texttt{num\_nodes} & integer & number of nodes belonging to the column \\
      \texttt{num\_layers} & integer & number of layers in the column below the ground surface \\
      \texttt{side\_ratio} & float & ratio of largest to smallest side length \\
      \texttt{surface} & float & surface elevation of the column (\texttt{None} if not specified)\\
      \hline
    \end{tabular}
    \caption{Properties of a \texttt{column} object}
    \label{tb:column_properties}
  \end{center}
\end{table}

\subsection{\texttt{layer} objects}

A \texttt{layer} object represents a layer in a \texttt{mulgrid} object. The properties of a \texttt{layer} object are given in Table \ref{tb:layer_properties}.

A \texttt{layer} object \texttt{lay} can be created for example using the command \texttt{lay = layer(name,bottom,centre,top)} where \texttt{name} is the layer name and \texttt{bottom}, \texttt{centre} and \texttt{top} specify the vertical position of the layer.

The methods of a \texttt{layer} object are as follows:

\subsubsection{\texttt{contains\_elevation(\emph{z})}}

Returns \texttt{True} if a point at a given elevation lies inside the layer, and \texttt{False} otherwise.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{z}: float\\
   Elevation of the point.
\end{itemize}

\subsubsection{\texttt{translate(\emph{shift})}}

Translates a layer up or down by a specified distance.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{shift}: float\\
  Distance to shift the layer (positive for up, negative for down).
\end{itemize}

\begin{table}
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Property} & \textbf{Type} & \textbf{Description}\\
      \hline
      \texttt{bottom} & float & elevation of the bottom of the layer \\
      \texttt{centre} & float & elevation of the centre of the layer \\
      \texttt{thickness} & float & layer thickness (top - bottom) \\
      \texttt{top} & float & elevation of the top of the layer \\
      \texttt{name} & string & name of the layer \\
      \hline
    \end{tabular}
    \caption{Properties of a \texttt{layer} object}
    \label{tb:layer_properties}
  \end{center}
\end{table}

\subsection{\texttt{connection} objects}
\label{connections}

A \texttt{connection} object represents a connection between \texttt{columns} in a \texttt{mulgrid} object.  It has three properties: \texttt{column}, which contains a two-element list of the \texttt{column} objects making up the connection, \texttt{node}, which contains a two-element list of the \texttt{nodes} on the face joining the two columns in the connection, and \texttt{angle\_cosine}, which gives the cosine of the angle between a line joining the nodes in the connection and a line joining the centres of the two columns.  This is used as a measure of grid quality, these two lines should ideally be as close to perpendicular as possible, making the cosine of the angle zero.  A \texttt{connection} has no methods.

A \texttt{connection} object \texttt{con} can be created for example using the command \texttt{con = connection(cols)} where \texttt{cols} is a two-element list of the \texttt{column} objects in the connection.

\subsection{\texttt{well} objects}

A \texttt{well} object represents a well in a \texttt{mulgrid} object.  The properties of a \texttt{well} object are given in Table \ref{tb:well_properties}.

\begin{table}
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Property} & \textbf{Type} & \textbf{Description}\\
      \hline
      \texttt{bottom} & \texttt{np.array} & well bottom position \\
      \texttt{deviated} & Boolean &  whether well is deviated\\
      \texttt{head} & \texttt{np.array} & well head position \\
      \texttt{name} & string & well name \\
      \texttt{num\_deviations} & integer & number of deviations \\
      \texttt{num\_pos} & integer & number of well track nodes \\
      \texttt{pos} & list & positions (3-D arrays) of well track nodes \\
      \texttt{pos\_depth} & \texttt{np.array} & downhole depths along well track \\
      \hline
    \end{tabular}
    \caption{Properties of a \texttt{well} object}
    \label{tb:well_properties}
  \end{center}
\end{table}

The well track can be deviated, and is defined as a list \texttt{pos} of (at least two) 3D positions (\texttt{np.arrays}).  The \texttt{num\_deviations} property returns the number of deviations in the track (one less than the \texttt{num\_pos} property, which is the number of nodes in the \texttt{pos} list).  The \texttt{deviated} property returns \texttt{True} if there is more than one deviation.  The \texttt{pos\_depth} property returns an array of the downhole depths at each node along the well track.

A \texttt{well} object \texttt{w} can be created simply with the command \texttt{w = well(name,pos)}, where \texttt{name} is the well name and \texttt{pos} is a list of 3-element \texttt{np.arrays} (or lists, or tuples) representing the well trace (starting from the wellhead).

The methods of a \texttt{well} are listed in Table \ref{tb:well_methods} and described below.

\begin{table}
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Method} & \textbf{Type} & \textbf{Description}\\
      \hline
      \texttt{depth\_elevation} & float & elevation for a given downhole depth \\
      \texttt{depth\_pos} & \texttt{np.array} & position on well track for a given downhole depth \\
      \texttt{elevation\_depth} & float & downhole depth for a given elevation \\
      \texttt{elevation\_pos} & \texttt{np.array} & position on well track for a given elevation \\
      \texttt{pos\_coordinate} & \texttt{np.array} & array of coordinates for a given index \\
      \hline
    \end{tabular}
    \caption{Methods of a \texttt{well} object}
    \label{tb:well_methods}
  \end{center}
\end{table}

\subsubsection{\texttt{depth\_elevation(\emph{depth})}}

Returns the elevation corresponding to the specified downhole \texttt{depth} (or \texttt{None} if \texttt{depth} is above the wellhead or below the bottom).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{depth}: float\\
  Downhole depth.
\end{itemize}

\subsubsection{\texttt{depth\_pos(\emph{depth})}}

Returns the 3D position of the point in the well with specified downhole \texttt{depth} (or \texttt{None} if \texttt{depth} is above the wellhead or below the bottom).  The position is interpolated between the deviation locations.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{depth}: float\\
  Downhole depth of the required point.
\end{itemize}

\subsubsection{\texttt{elevation\_depth(\emph{elevation})}}

Returns the downhole depth corresponding to the specified \texttt{elevation} (or \texttt{None} if \texttt{elevation} is above the wellhead or below the bottom).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{elevation}: float\\
  Elevation.
\end{itemize}

\subsubsection{\texttt{elevation\_pos(\emph{elevation}, \emph{extend}=\texttt{False})}}

Returns the 3D position of the point in the well with specified \texttt{elevation} (or \texttt{None} if \texttt{elevation} is above the wellhead or below the bottom).  The position is interpolated between the deviation locations.  If \texttt{extend} is \texttt{True}, return extrapolated positions for elevations below the bottom of the well.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{elevation}: float\\
  Elevation of the required point.
\item \textbf{extend}: Boolean\\
  If \texttt{True}, extrapolated positions will be returned for elevations below the bottom of the well (otherwise \texttt{None} will be returned).
\end{itemize}

\subsubsection{\texttt{pos\_coordinate(\emph{index})}}

Returns an \texttt{np.array} of the well track node coordinates for the given index (0, 1 or 2).  For example, \texttt{pos\_coordinate(2)} returns an array containing the elevations of all well track nodes.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{index}: integer\\
  Index required (0, 1 or 2).
\end{itemize}

\section{Other functions: block name conversions}

The \texttt{mulgrids} library contains two other functions connected with working with geometry files and TOUGH2 grids:

\subsubsection{\texttt{fix\_blockname(\emph{name})}}

TOUGH2 always assumes that the last two characters of a block name represent a two-digit number.  However, if that number is less than 10, the fourth character is not padded with zeros, so for example `AA101' becomes 'AA1 1' when processed by TOUGH2.

The \texttt{fix\_blockname} function corrects this by padding the fourth character of a block name with a zero if necessary.  This is only done if the third character is also a digit, e.g. when naming convention 2 is used (two characters for layer followed by three digits for column).

\textbf{Parameters:}
\begin{itemize}
\item \textbf{name}: string\\
  Block name.
\end{itemize}

\subsubsection{\texttt{unfix\_blockname(\emph{name})}}

This function reverses the effect of \texttt{fix\_blockname()}.

\textbf{Parameters:}
\begin{itemize}
\item \textbf{name}: string\\
  Block name.
\end{itemize}

